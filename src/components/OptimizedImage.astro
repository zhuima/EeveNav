---
interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'lazy' | 'eager';
  sizes?: string;
  class?: string;
  priority?: boolean;
}

const {
  src,
  alt,
  width,
  height,
  loading = 'lazy',
  sizes = '(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw',
  class: className = '',
  priority = false
} = Astro.props;

// 生成不同尺寸的图片URL（如果有CDN）
function generateSrcSet(baseUrl: string, widths: number[]): string {
  return widths
    .map(w => `${baseUrl}?w=${w} ${w}w`)
    .join(', ');
}

// 生成优化的图片URL
function optimizeImageUrl(url: string, width?: number, height?: number): string {
  try {
    const urlObj = new URL(url);

    // 如果是外部图片，添加优化参数
    if (urlObj.hostname.includes('unsplash.com') ||
        urlObj.hostname.includes('picsum.photos') ||
        urlObj.hostname.includes('cloudinary.com')) {

      const params = new URLSearchParams(urlObj.search);
      if (width) params.set('w', width.toString());
      if (height) params.set('h', height.toString());
      params.set('q', '80'); // 质量设置
      params.set('auto', 'format'); // 自动格式

      urlObj.search = params.toString();
      return urlObj.toString();
    }

    return url;
  } catch {
    return url;
  }
}

const optimizedSrc = optimizeImageUrl(src, width, height);
const srcSet = generateSrcSet(src, [320, 640, 768, 1024, 1280, 1536]);
---

<div class={`relative overflow-hidden ${className}`}>
  <!-- 图片容器 -->
  <img
    src={optimizedSrc}
    srcset={srcSet}
    sizes={sizes}
    alt={alt}
    width={width}
    height={height}
    loading={priority ? 'eager' : loading}
    decoding={priority ? 'sync' : 'async'}
    class="w-full h-full object-cover transition-opacity duration-300"
    onload="this.classList.add('loaded')"
    onerror="this.classList.add('error')"
  />

  <!-- 加载状态 -->
  <div class="absolute inset-0 bg-gray-100 animate-pulse" id="skeleton-{@props.src}"></div>

  <!-- 错误状态 -->
  <div class="absolute inset-0 bg-gray-200 hidden items-center justify-center" id="error-{@props.src}">
    <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
    </svg>
  </div>
</div>

<style>
  .loaded {
    opacity: 1;
  }

  .loaded + #skeleton-\{src\} {
    display: none;
  }

  .error {
    opacity: 0.5;
  }

  .error + #skeleton-\{src\} {
    display: none;
  }

  .error ~ #error-\{src\} {
    display: flex;
  }

  /* 图片懒加载优化 */
  img[loading="lazy"] {
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }

  img[loading="lazy"].loaded {
    opacity: 1;
  }

  /* 提高性能的CSS属性 */
  .optimized-image {
    contain: layout style paint;
    will-change: opacity;
  }
</style>

<script>
  // 图片懒加载和错误处理
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('img[loading="lazy"]');

    // 使用Intersection Observer实现懒加载
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;

            // 预加载图片
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
            }

            imageObserver.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px',
        threshold: 0.01
      });

      images.forEach(img => imageObserver.observe(img));
    } else {
      // 降级处理
      images.forEach(img => {
        if (img.dataset.src) {
          img.src = img.dataset.src;
        }
      });
    }
  });
</script>